name: GPU Droplet Benchmarking

# Uses SSH_PRIVATE_KEY secret for droplet health checks

on:
  workflow_dispatch:
    inputs:
      slug:
        description: 'Droplet size slug (e.g., s-1vcpu-1gb, g-2vcpu-8gb-nvidia-l4)'
        required: true
        type: string
        default: 'gpu-h100x1-80gb'
      region:
        description: 'DigitalOcean region (e.g., nyc1, nyc3, sfo3, tor1)'
        required: true
        type: string
        default: 'tor1'
      image:
        description: 'Droplet image (e.g., ubuntu-22-04-x64, gpu-h100x8-base)'
        required: true
        type: string
        default: 'gpu-h100x1-base'
      ssh_keys:
        description: 'SSH key names (comma-separated, get with: doctl compute ssh-key list)'
        required: true
        type: string
        default: 'github-actions, macbook'

jobs:
  create-gpu-droplet:
    runs-on: ubuntu-latest
    outputs:
      droplet-id: ${{ steps.create.outputs.droplet-id }}
      droplet-name: ${{ steps.create.outputs.droplet-name }}
      creation-success: ${{ steps.create.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Validate inputs
        run: |
          echo "üîç Validating inputs..."
          
          # Check if region exists
          echo "Checking region: ${{ github.event.inputs.region }}"
          if ! doctl compute region list --format Slug --no-header | grep -q "^${{ github.event.inputs.region }}$"; then
            echo "‚ùå Error: Region '${{ github.event.inputs.region }}' not found!"
            echo "Available regions:"
            doctl compute region list --format Slug,Name,Available
            exit 1
          fi
          echo "‚úÖ Region '${{ github.event.inputs.region }}' is valid"
          
          # Check if size exists
          echo "Checking droplet size: ${{ github.event.inputs.slug }}"
          if ! doctl compute size list --format Slug --no-header | grep -q "^${{ github.event.inputs.slug }}$"; then
            echo "‚ùå Error: Droplet size '${{ github.event.inputs.slug }}' not found!"
            echo "Available sizes:"
            doctl compute size list --format Slug,Memory,VCPUs,Disk,PriceMonthly
            exit 1
          fi
          echo "‚úÖ Droplet size '${{ github.event.inputs.slug }}' is valid"
          
          # Validate SSH keys
          echo "Validating SSH keys: ${{ github.event.inputs.ssh_keys }}"
          IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.ssh_keys }}"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            if ! doctl compute ssh-key list --format Name --no-header | grep -q "^${key_name}$"; then
              echo "‚ùå Error: SSH key name '${key_name}' not found!"
              echo "Available SSH keys:"
              doctl compute ssh-key list --format ID,Name,Fingerprint
              exit 1
            fi
          done
          echo "‚úÖ All SSH key names are valid"

      - name: Create droplet
        id: create
        run: |
          # Generate unique droplet name
          DROPLET_NAME="gpu-droplet-benchmark-$(date +%s)"
          echo "üöÄ Creating droplet: $DROPLET_NAME"
          
          # Convert SSH key names to IDs and format for doctl
          echo "Converting SSH key names to IDs..."
          SSH_KEY_IDS=""
          IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.ssh_keys }}"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            key_id=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$key_name$" | awk '{print $1}')
            if [ -n "$SSH_KEY_IDS" ]; then
              SSH_KEY_IDS="$SSH_KEY_IDS,$key_id"
            else
              SSH_KEY_IDS="$key_id"
            fi
            echo "  '$key_name' ‚Üí ID: $key_id"
          done
          
          echo ""
          echo "Configuration:"
          echo "  Name: $DROPLET_NAME"
          echo "  Size: ${{ github.event.inputs.slug }}"
          echo "  Region: ${{ github.event.inputs.region }}"
          echo "  Image: ${{ github.event.inputs.image }}"
          echo "  SSH Key Names: ${{ github.event.inputs.ssh_keys }}"
          echo "  SSH Key IDs: $SSH_KEY_IDS"
          echo ""
          
          # Create the droplet
          echo "‚è≥ Creating droplet..."
          if DROPLET_OUTPUT=$(doctl compute droplet create "$DROPLET_NAME" \
            --size "${{ github.event.inputs.slug }}" \
            --region "${{ github.event.inputs.region }}" \
            --image "${{ github.event.inputs.image }}" \
            --ssh-keys $SSH_KEY_IDS \
            --tag-names "gpu-droplet-benchmark,github-actions" \
            --format ID \
            --no-header 2>&1); then
            
            # Extract droplet ID - should be a single line with just the ID
            DROPLET_ID=$(echo "$DROPLET_OUTPUT" | head -n1 | xargs)
            
            # Validate we got a single numeric ID
            if [[ ! "$DROPLET_ID" =~ ^[0-9]+$ ]]; then
              echo "‚ùå ERROR: Invalid droplet ID received: '$DROPLET_ID'"
              echo "Full output was:"
              echo "$DROPLET_OUTPUT"
              exit 1
            fi
            
            echo "üéâ SUCCESS: Droplet created successfully!"
            echo "Droplet ID: $DROPLET_ID"
            echo "Droplet Name: $DROPLET_NAME"
            echo ""
            
            # Get detailed droplet info for display
            echo "üìä Droplet details:"
            doctl compute droplet get "$DROPLET_ID" --format ID,Name,Memory,VCPUs,Disk,Region,Image,Status
            
            # Set outputs for next job
            echo "droplet-id=$DROPLET_ID" >> $GITHUB_OUTPUT
            echo "droplet-name=$DROPLET_NAME" >> $GITHUB_OUTPUT
            echo "success=true" >> $GITHUB_OUTPUT
            
          else
            echo "‚ùå FAILED: Could not create droplet"
            echo "Error details:"
            echo "$DROPLET_OUTPUT"
            
            # Analyze the error
            if echo "$DROPLET_OUTPUT" | grep -i "insufficient\|capacity\|unavailable" > /dev/null; then
              echo ""
              echo "üí° Analysis: No capacity available for this droplet size in region ${{ github.event.inputs.region }}"
            elif echo "$DROPLET_OUTPUT" | grep -i "invalid\|not found" > /dev/null; then
              echo ""
              echo "üí° Analysis: Invalid configuration - check size/region/image combination"
            elif echo "$DROPLET_OUTPUT" | grep -i "limit\|quota" > /dev/null; then
              echo ""
              echo "üí° Analysis: Account limits reached"
            fi
            
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Wait for droplet to be ready
        if: steps.create.outputs.success == 'true'
        run: |
          echo "‚è≥ Waiting for droplet to become active..."
          DROPLET_ID="${{ steps.create.outputs.droplet-id }}"
          
          # Wait up to 5 minutes for droplet to be active
          for i in {1..30}; do
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
            echo "Attempt $i/30: Status is '$STATUS'"
            
            if [ "$STATUS" = "active" ]; then
              echo "‚úÖ Droplet is now active!"
              
              # Get full droplet details
              echo ""
              echo "üìä Final droplet details:"
              doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Memory,VCPUs,Disk,Region,Image,Status
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ö†Ô∏è Droplet did not become active within 5 minutes, but continuing..."
            fi
            
            sleep 10
          done

  create-cpu-droplet:
    runs-on: ubuntu-latest
    outputs:
      droplet-id: ${{ steps.create.outputs.droplet-id }}
      droplet-name: ${{ steps.create.outputs.droplet-name }}
      creation-success: ${{ steps.create.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Validate SSH keys
        run: |
          echo "üîç Validating SSH keys for CPU droplet..."
          
          # Validate predefined SSH keys
          SSH_KEY_NAMES="github-actions,macbook"
          IFS=',' read -ra SSH_KEYS <<< "$SSH_KEY_NAMES"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            if ! doctl compute ssh-key list --format Name --no-header | grep -q "^${key_name}$"; then
              echo "‚ùå Error: SSH key name '${key_name}' not found!"
              echo "Available SSH keys:"
              doctl compute ssh-key list --format ID,Name,Fingerprint
              exit 1
            fi
          done
          echo "‚úÖ All SSH key names are valid"

      - name: Create CPU droplet
        id: create
        run: |
          # Generate unique droplet name
          DROPLET_NAME="cpu-droplet-benchmark-$(date +%s)"
          echo "üöÄ Creating CPU droplet: $DROPLET_NAME"
          
          # Convert SSH key names to IDs for CPU droplet
          echo "Converting SSH key names to IDs..."
          SSH_KEY_IDS=""
          SSH_KEY_NAMES="github-actions,macbook"
          IFS=',' read -ra SSH_KEYS <<< "$SSH_KEY_NAMES"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            key_id=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$key_name$" | awk '{print $1}')
            if [ -n "$SSH_KEY_IDS" ]; then
              SSH_KEY_IDS="$SSH_KEY_IDS,$key_id"
            else
              SSH_KEY_IDS="$key_id"
            fi
            echo "  '$key_name' ‚Üí ID: $key_id"
          done
          
          echo ""
          echo "CPU Droplet Configuration:"
          echo "  Name: $DROPLET_NAME"
          echo "  Size: c-2"
          echo "  Region: tor1"
          echo "  Image: ubuntu-24-04-x64"
          echo "  SSH Key Names: github-actions, macbook"
          echo "  SSH Key IDs: $SSH_KEY_IDS"
          echo ""
          
          # Create the CPU droplet
          echo "‚è≥ Creating CPU droplet..."
          if DROPLET_OUTPUT=$(doctl compute droplet create "$DROPLET_NAME" \
            --size "c-2" \
            --region "tor1" \
            --image "ubuntu-24-04-x64" \
            --ssh-keys $SSH_KEY_IDS \
            --tag-names "cpu-droplet-benchmark,github-actions" \
            --format ID \
            --no-header 2>&1); then
            
            # Extract droplet ID - should be a single line with just the ID
            DROPLET_ID=$(echo "$DROPLET_OUTPUT" | head -n1 | xargs)
            
            # Validate we got a single numeric ID
            if [[ ! "$DROPLET_ID" =~ ^[0-9]+$ ]]; then
              echo "‚ùå ERROR: Invalid droplet ID received: '$DROPLET_ID'"
              echo "Full output was:"
              echo "$DROPLET_OUTPUT"
              exit 1
            fi
            
            echo "üéâ SUCCESS: CPU Droplet created successfully!"
            echo "Droplet ID: $DROPLET_ID"
            echo "Droplet Name: $DROPLET_NAME"
            echo ""
            
            # Get detailed droplet info for display
            echo "üìä CPU Droplet details:"
            doctl compute droplet get "$DROPLET_ID" --format ID,Name,Memory,VCPUs,Disk,Region,Image,Status
            
            # Set outputs for next job
            echo "droplet-id=$DROPLET_ID" >> $GITHUB_OUTPUT
            echo "droplet-name=$DROPLET_NAME" >> $GITHUB_OUTPUT
            echo "success=true" >> $GITHUB_OUTPUT
            
          else
            echo "‚ùå FAILED: Could not create CPU droplet"
            echo "Error details:"
            echo "$DROPLET_OUTPUT"
            
            # Analyze the error
            if echo "$DROPLET_OUTPUT" | grep -i "insufficient\|capacity\|unavailable" > /dev/null; then
              echo ""
              echo "üí° Analysis: No capacity available for CPU droplet in region tor1"
            elif echo "$DROPLET_OUTPUT" | grep -i "invalid\|not found" > /dev/null; then
              echo ""
              echo "üí° Analysis: Invalid configuration - check size/region/image combination"
            elif echo "$DROPLET_OUTPUT" | grep -i "limit\|quota" > /dev/null; then
              echo ""
              echo "üí° Analysis: Account limits reached"
            fi
            
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Wait for CPU droplet to be ready
        if: steps.create.outputs.success == 'true'
        run: |
          echo "‚è≥ Waiting for CPU droplet to become active..."
          DROPLET_ID="${{ steps.create.outputs.droplet-id }}"
          
          # Wait up to 5 minutes for droplet to be active
          for i in {1..30}; do
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
            echo "Attempt $i/30: Status is '$STATUS'"
            
            if [ "$STATUS" = "active" ]; then
              echo "‚úÖ CPU Droplet is now active!"
              
              # Get full droplet details
              echo ""
              echo "üìä Final CPU droplet details:"
              doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Memory,VCPUs,Disk,Region,Image,Status
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ö†Ô∏è CPU Droplet did not become active within 5 minutes, but continuing..."
            fi
            
            sleep 10
          done

  health-check:
    runs-on: ubuntu-latest
    needs: create-gpu-droplet
    if: needs.create-gpu-droplet.outputs.creation-success == 'true'
    outputs:
      health-check-success: ${{ steps.health.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Get droplet IP address
        id: get-ip
        run: |
          DROPLET_ID="${{ needs.create-gpu-droplet.outputs.droplet-id }}"
          echo "Getting IP address for droplet $DROPLET_ID..."
          
          # Wait a bit more for IP to be assigned
          sleep 10
          
          PUBLIC_IP=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
          echo "Public IP: $PUBLIC_IP"
          
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "<nil>" ]; then
            echo "‚ùå No public IP assigned yet, waiting..."
            for i in {1..10}; do
              sleep 10
              PUBLIC_IP=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
              echo "Attempt $i: IP is '$PUBLIC_IP'"
              if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "<nil>" ]; then
                break
              fi
            done
          fi
          
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "<nil>" ]; then
            echo "‚ùå Failed to get public IP address"
            exit 1
          fi
          
          echo "‚úÖ Got public IP: $PUBLIC_IP"
          echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the private key from GitHub secrets
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Set SSH options for automated connections
          cat > ~/.ssh/config << EOF
          Host droplet-test
            HostName ${{ steps.get-ip.outputs.public-ip }}
            User root
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ConnectTimeout 30
            ServerAliveInterval 60
          EOF
          
          chmod 600 ~/.ssh/config
          echo "‚úÖ SSH key and config created"

      - name: Wait for SSH to be ready
        run: |
          echo "‚è≥ Waiting for SSH service to be ready..."
          PUBLIC_IP="${{ steps.get-ip.outputs.public-ip }}"
          
          # Debug SSH setup
          echo "üîç SSH setup verification:"
          echo "Private key exists: $([ -f ~/.ssh/id_rsa ] && echo 'YES' || echo 'NO')"
          echo "Private key permissions: $(stat -c %a ~/.ssh/id_rsa 2>/dev/null || echo 'N/A')"
          echo "SSH config exists: $([ -f ~/.ssh/config ] && echo 'YES' || echo 'NO')"
          echo ""
          
          # Test actual SSH connectivity with key authentication
          for i in {1..30}; do
            echo "Attempt $i/30: Testing SSH connection..."
            if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 root@$PUBLIC_IP 'echo "SSH connection successful"' 2>/dev/null; then
              echo "‚úÖ SSH connection established!"
              sleep 2  # Give it a moment to fully initialize
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå SSH service did not become ready within 5 minutes"
              echo "üîç Final SSH debug attempt:"
              ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -v root@$PUBLIC_IP 'echo "Debug connection"' || true
              exit 1
            fi
            
            sleep 10
          done

      - name: Health check via SSH
        id: health
        run: |
          echo "üè• Starting health check..."
          PUBLIC_IP="${{ steps.get-ip.outputs.public-ip }}"
          HEALTH_SUCCESS=true
          
          echo "Running health checks on $PUBLIC_IP..."
          echo ""
          
          # Debug SSH connection
          echo "üîç Testing SSH connection first..."
          ssh -F ~/.ssh/config -o ConnectTimeout=10 droplet-test 'echo "SSH test successful"' || {
            echo "‚ùå SSH connection failed, trying direct connection..."
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 root@$PUBLIC_IP 'echo "Direct SSH test successful"'
          }
          echo ""
          
          # 1. Docker check
          echo "1. üê≥ Checking Docker installation..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'docker --version && docker info > /dev/null 2>&1'; then
            echo "‚úÖ Docker is installed and running"
          else
            echo "‚ùå Docker check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 2. NVIDIA GPU check
          echo "2. üîß Checking NVIDIA GPU drivers..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'nvidia-smi'; then
            echo "‚úÖ NVIDIA drivers working and GPU detected"
          else
            echo "‚ùå NVIDIA GPU check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 3. Python and vLLM availability check
          echo "3. üöÄ Checking vLLM availability..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'python3 -c "import vllm; print(f\"vLLM version: {vllm.__version__}\")"'; then
            echo "‚úÖ vLLM is available"
          else
            echo "‚ùå vLLM check failed (may not be pre-installed)"
            # Don't fail the health check for vLLM as it might need to be installed
            echo "‚ÑπÔ∏è  vLLM can be installed as needed"
          fi
          echo ""
          
          # 4. GPU-enabled Docker test
          echo "4. üéØ Testing GPU-enabled Docker runtime..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=60 root@$PUBLIC_IP 'docker run --rm --gpus all nvidia/cuda:12.0-base-ubuntu20.04 nvidia-smi'; then
            echo "‚úÖ GPU-enabled Docker containers work correctly"
          else
            echo "‚ùå GPU Docker runtime check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 5. System resources check
          echo "5. üìä Checking system resources..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'df -h / && free -h && uptime'; then
            echo "‚úÖ System resources checked"
          else
            echo "‚ùå System resources check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          if [ "$HEALTH_SUCCESS" = "true" ]; then
            echo "ÔøΩ All critical health checks passed!"
            echo "‚úÖ GPU droplet is ready for vLLM workloads"
          else
            echo "‚ö†Ô∏è Some health checks failed"
            echo "‚ùå GPU droplet may not be fully ready"
          fi
          
          echo "success=$HEALTH_SUCCESS" >> $GITHUB_OUTPUT

      - name: Health check summary
        run: |
          echo "## üè• Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Droplet IP:** \`${{ steps.get-ip.outputs.public-ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Checks Performed:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ SSH connectivity established" >> $GITHUB_STEP_SUMMARY
          echo "- üê≥ Docker installation and service status" >> $GITHUB_STEP_SUMMARY
          echo "- üîß NVIDIA drivers and GPU detection" >> $GITHUB_STEP_SUMMARY  
          echo "- üöÄ vLLM framework availability (optional)" >> $GITHUB_STEP_SUMMARY
          echo "- üéØ GPU-enabled Docker runtime test" >> $GITHUB_STEP_SUMMARY
          echo "- üìä System resources and uptime" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.health.outputs.success }}" = "true" ]; then
            echo "**Status: ‚úÖ ALL CHECKS PASSED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **GPU droplet is ready for vLLM workloads!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ‚ùå SOME CHECKS FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **GPU droplet may need additional setup.**" >> $GITHUB_STEP_SUMMARY
          fi

  setup-dependencies:
    runs-on: ubuntu-latest
    needs: [create-gpu-droplet, health-check]
    if: needs.create-gpu-droplet.outputs.creation-success == 'true'
    outputs:
      setup-success: ${{ steps.setup.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the private key from GitHub secrets
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Setup missing dependencies
        id: setup
        run: |
          echo "üîß Setting up missing dependencies..."
          PUBLIC_IP=$(doctl compute droplet get "${{ needs.create-gpu-droplet.outputs.droplet-id }}" --format PublicIPv4 --no-header)
          SETUP_SUCCESS=true
          
          echo "Setting up dependencies on $PUBLIC_IP..."
          echo ""
          
          # 1. Install vLLM
          echo "1. üöÄ Installing vLLM..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=60 root@$PUBLIC_IP '
            echo "Installing Python pip and vLLM..."
            apt-get update
            apt-get install -y python3-pip python3-venv
            python3 -m pip install --upgrade pip
            python3 -m pip install vllm
            echo "vLLM installation completed"
          '; then
            echo "‚úÖ vLLM installed successfully"
          else
            echo "‚ùå vLLM installation failed"
            SETUP_SUCCESS=false
          fi
          echo ""
          
          # 2. Setup NVIDIA Container Toolkit for Docker
          echo "2. üê≥ Setting up NVIDIA Container Toolkit..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=120 root@$PUBLIC_IP '
            echo "Installing NVIDIA Container Toolkit..."
            
            # Add NVIDIA package repository
            curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
            curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \
              sed "s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g" | \
              tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
            
            # Install NVIDIA Container Toolkit
            apt-get update -qq
            apt-get install -y nvidia-container-toolkit
            
            # Configure Docker to use NVIDIA runtime
            nvidia-ctk runtime configure --runtime=docker
            systemctl restart docker
            
            echo "NVIDIA Container Toolkit setup completed"
          '; then
            echo "‚úÖ NVIDIA Container Toolkit installed successfully"
          else
            echo "‚ùå NVIDIA Container Toolkit installation failed"
            SETUP_SUCCESS=false
          fi
          echo ""
          
          # 3. Test GPU Docker with correct image
          echo "3. üéØ Testing GPU-enabled Docker with available image..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=120 root@$PUBLIC_IP '
            echo "Testing GPU Docker runtime..."
            docker run --rm --gpus all nvidia/cuda:12.0-runtime-ubuntu22.04 nvidia-smi
          '; then
            echo "‚úÖ GPU Docker runtime working correctly"
          else
            echo "‚ö†Ô∏è GPU Docker test failed, but toolkit is installed"
            echo "‚ÑπÔ∏è  This may work after a brief delay for Docker to fully restart"
          fi
          echo ""
          
          # 4. Verify vLLM installation
          echo "4. ‚úÖ Verifying vLLM installation..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP '
            echo "Checking vLLM installation..."
            python3 -c "import sys; print(f\"Python version: {sys.version}\")"
            python3 -c "import vllm; print(f\"vLLM version: {vllm.__version__}\")"
          '; then
            echo "‚úÖ vLLM is now available and working"
          else
            echo "‚ùå vLLM verification failed"
            echo "üîç Debugging vLLM installation..."
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP '
              echo "Installed packages containing vllm:"
              python3 -m pip list | grep -i vllm || echo "No vLLM packages found"
              echo "Python path:"
              python3 -c "import sys; print(sys.path)"
            ' || true
            SETUP_SUCCESS=false
          fi
          echo ""
          
          if [ "$SETUP_SUCCESS" = "true" ]; then
            echo "üéâ All dependencies installed successfully!"
            echo "‚úÖ GPU droplet is now fully ready for vLLM workloads"
          else
            echo "‚ö†Ô∏è Some dependency installations failed"
            echo "‚ùå Manual intervention may be required"
          fi
          
          echo "success=$SETUP_SUCCESS" >> $GITHUB_OUTPUT

      - name: Setup summary
        run: |
          echo "## üîß Dependency Setup Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Components Installed:" >> $GITHUB_STEP_SUMMARY
          echo "- üöÄ **vLLM Framework** - Python package for LLM inference" >> $GITHUB_STEP_SUMMARY
          echo "- üê≥ **NVIDIA Container Toolkit** - GPU support for Docker" >> $GITHUB_STEP_SUMMARY
          echo "- üéØ **GPU Docker Runtime** - Tested with nvidia/cuda image" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.setup.outputs.success }}" = "true" ]; then
            echo "**Status: ‚úÖ SETUP SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **All dependencies are now installed and ready!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ‚ùå SETUP ISSUES**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **Some installations failed. Check logs for details.**" >> $GITHUB_STEP_SUMMARY
          fi

  destroy-cpu-droplet:
    runs-on: ubuntu-latest
    needs: [create-cpu-droplet]
    if: always() && needs.create-cpu-droplet.outputs.creation-success == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Destroy CPU droplet
        run: |
          DROPLET_ID="${{ needs.create-cpu-droplet.outputs.droplet-id }}"
          DROPLET_NAME="${{ needs.create-cpu-droplet.outputs.droplet-name }}"
          
          echo "üßπ Destroying CPU test droplet..."
          echo "Droplet ID: $DROPLET_ID"
          echo "Droplet Name: $DROPLET_NAME"
          echo ""
          
          # Show droplet details before deletion
          echo "üìä Current CPU droplet status:"
          doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Status || echo "Could not get droplet details"
          echo ""
          
          # Delete the droplet
          echo "üóëÔ∏è Deleting CPU droplet..."
          if doctl compute droplet delete "$DROPLET_ID" --force; then
            echo "‚úÖ CPU Droplet deleted successfully!"
            
            # Verify deletion
            echo ""
            echo "üîç Verifying deletion..."
            sleep 5
            
            if doctl compute droplet get "$DROPLET_ID" --format ID --no-header 2>/dev/null; then
              echo "‚ö†Ô∏è CPU Droplet still exists, but deletion command succeeded (may take a moment)"
            else
              echo "‚úÖ Confirmed: CPU Droplet has been completely removed"
            fi
          else
            echo "‚ùå Failed to delete CPU droplet!"
            echo "‚ö†Ô∏è IMPORTANT: Manual cleanup may be required!"
            echo "Run: doctl compute droplet delete $DROPLET_ID --force"
            exit 1
          fi

  # destroy-droplet:
  #   runs-on: ubuntu-latest
  #   needs: [create-droplet, health-check]
  #   if: always() && needs.create-droplet.outputs.creation-success == 'true'
  #   
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Install doctl
  #       uses: digitalocean/action-doctl@v2
  #       with:
  #         token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

  #     - name: Destroy droplet
  #       run: |
  #         DROPLET_ID="${{ needs.create-droplet.outputs.droplet-id }}"
  #         DROPLET_NAME="${{ needs.create-droplet.outputs.droplet-name }}"
  #         
  #         echo "üßπ Destroying test droplet..."
  #         echo "Droplet ID: $DROPLET_ID"
  #         echo "Droplet Name: $DROPLET_NAME"
  #         echo ""
  #         
  #         # Show droplet details before deletion
  #         echo "üìä Current droplet status:"
  #         doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Status || echo "Could not get droplet details"
  #         echo ""
  #         
  #         # Delete the droplet
  #         echo "üóëÔ∏è Deleting droplet..."
  #         if doctl compute droplet delete "$DROPLET_ID" --force; then
  #           echo "‚úÖ Droplet deleted successfully!"
  #           
  #           # Verify deletion
  #           echo ""
  #           echo "üîç Verifying deletion..."
  #           sleep 5
  #           
  #           if doctl compute droplet get "$DROPLET_ID" --format ID --no-header 2>/dev/null; then
  #             echo "‚ö†Ô∏è Droplet still exists, but deletion command succeeded (may take a moment)"
  #           else
  #             echo "‚úÖ Confirmed: Droplet has been completely removed"
  #           fi
  #         else
  #           echo "‚ùå Failed to delete droplet!"
  #           echo "‚ö†Ô∏è IMPORTANT: Manual cleanup may be required!"
  #           echo "Run: doctl compute droplet delete $DROPLET_ID --force"
  #           exit 1
  #         fi

  summary:
    runs-on: ubuntu-latest
    needs: [create-gpu-droplet, create-cpu-droplet, health-check, setup-dependencies, destroy-cpu-droplet]
    if: always()
    
    steps:
      - name: Generate workflow summary
        run: |
          echo "## üß™ Droplet Capacity Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**GPU Droplet Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Slug:** \`${{ github.event.inputs.slug }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`${{ github.event.inputs.region }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ github.event.inputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **SSH Key Names:** \`${{ github.event.inputs.ssh_keys }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**CPU Droplet Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Slug:** \`c-2\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`tor1\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`ubuntu-24-04-x64\`" >> $GITHUB_STEP_SUMMARY
          echo "- **SSH Key Names:** \`github-actions, macbook\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check GPU creation result
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚úÖ GPU Creation: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet ID:** \`${{ needs.create-gpu-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet Name:** \`${{ needs.create-gpu-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **GPU Capacity is available!** The GPU droplet was created successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå GPU Creation: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **No GPU capacity available** or configuration issue." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check CPU creation result
          if [ "${{ needs.create-cpu-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚úÖ CPU Creation: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet ID:** \`${{ needs.create-cpu-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet Name:** \`${{ needs.create-cpu-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **CPU Capacity is available!** The CPU droplet was created successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå CPU Creation: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **No CPU capacity available** or configuration issue." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check health check result (GPU only)
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            if [ "${{ needs.health-check.outputs.health-check-success }}" = "true" ]; then
              echo "### üè• GPU Health Check: SUCCESS" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ All services (Docker, NVIDIA, vLLM) are ready on the GPU droplet." >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ö†Ô∏è GPU Health Check: FAILED" >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Some services may not be properly configured on GPU droplet." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ÑπÔ∏è GPU Health Check: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No GPU droplet was created, so health check was skipped." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check setup result (GPU only)
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            if [ "${{ needs.setup-dependencies.outputs.setup-success }}" = "true" ]; then
              echo "### üîß GPU Dependency Setup: SUCCESS" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ All missing components (vLLM, NVIDIA Container Toolkit) installed successfully on GPU droplet." >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.setup-dependencies.result }}" = "failure" ]; then
              echo "### ‚ùå GPU Dependency Setup: FAILED" >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Some dependencies failed to install properly on GPU droplet." >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ö†Ô∏è GPU Dependency Setup: SKIPPED" >> $GITHUB_STEP_SUMMARY
              echo "‚ÑπÔ∏è Setup job was skipped or didn't run." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ÑπÔ∏è GPU Dependency Setup: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No GPU droplet was created, so setup was skipped." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check CPU destruction result
          if [ "${{ needs.create-cpu-droplet.outputs.creation-success }}" = "true" ]; then
            if [ "${{ needs.destroy-cpu-droplet.result }}" = "success" ]; then
              echo "### ‚úÖ CPU Cleanup: SUCCESS" >> $GITHUB_STEP_SUMMARY
              echo "üßπ **CPU droplet was automatically destroyed.**" >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ùå CPU Cleanup: FAILED" >> $GITHUB_STEP_SUMMARY
              echo "‚ö†Ô∏è **CPU droplet cleanup failed. Manual cleanup required:**" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "doctl compute droplet delete ${{ needs.create-cpu-droplet.outputs.droplet-id }} --force" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ÑπÔ∏è CPU Cleanup: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No CPU droplet was created, so no cleanup needed." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check GPU destruction result (manual cleanup needed)
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚ö†Ô∏è GPU Cleanup: MANUAL REQUIRED" >> $GITHUB_STEP_SUMMARY
            echo "üîÑ **Automatic GPU cleanup is currently disabled.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Manual GPU cleanup required:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "doctl compute droplet delete ${{ needs.create-gpu-droplet.outputs.droplet-id }} --force" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**GPU Droplet Details:**" >> $GITHUB_STEP_SUMMARY
            echo "- **ID:** \`${{ needs.create-gpu-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Name:** \`${{ needs.create-gpu-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ÑπÔ∏è GPU Cleanup: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No GPU droplet was created, so no cleanup needed." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*This test creates both GPU and CPU droplets to verify capacity. CPU droplet is automatically destroyed, GPU droplet requires manual cleanup.*" >> $GITHUB_STEP_SUMMARY