name: GPU Droplet Benchmarking

# Uses SSH_PRIVATE_KEY secret for droplet health checks

on:
  workflow_dispatch:
    inputs:
      slug:
        description: 'Droplet size slug (e.g., s-1vcpu-1gb, g-2vcpu-8gb-nvidia-l4)'
        required: true
        type: string
        default: 'gpu-h100x1-80gb'
      region:
        description: 'DigitalOcean region (e.g., nyc1, nyc3, sfo3, tor1)'
        required: true
        type: string
        default: 'tor1'
      image:
        description: 'Droplet image (e.g., ubuntu-22-04-x64, gpu-h100x8-base)'
        required: true
        type: string
        default: 'gpu-h100x1-base'
      ssh_keys:
        description: 'SSH key names (comma-separated, get with: doctl compute ssh-key list)'
        required: true
        type: string
        default: 'github-actions, macbook'

jobs:
  create-droplet:
    runs-on: ubuntu-latest
    outputs:
      droplet-id: ${{ steps.create.outputs.droplet-id }}
      droplet-name: ${{ steps.create.outputs.droplet-name }}
      creation-success: ${{ steps.create.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Validate inputs
        run: |
          echo "üîç Validating inputs..."
          
          # Check if region exists
          echo "Checking region: ${{ github.event.inputs.region }}"
          if ! doctl compute region list --format Slug --no-header | grep -q "^${{ github.event.inputs.region }}$"; then
            echo "‚ùå Error: Region '${{ github.event.inputs.region }}' not found!"
            echo "Available regions:"
            doctl compute region list --format Slug,Name,Available
            exit 1
          fi
          echo "‚úÖ Region '${{ github.event.inputs.region }}' is valid"
          
          # Check if size exists
          echo "Checking droplet size: ${{ github.event.inputs.slug }}"
          if ! doctl compute size list --format Slug --no-header | grep -q "^${{ github.event.inputs.slug }}$"; then
            echo "‚ùå Error: Droplet size '${{ github.event.inputs.slug }}' not found!"
            echo "Available sizes:"
            doctl compute size list --format Slug,Memory,VCPUs,Disk,PriceMonthly
            exit 1
          fi
          echo "‚úÖ Droplet size '${{ github.event.inputs.slug }}' is valid"
          
          # Validate SSH keys
          echo "Validating SSH keys: ${{ github.event.inputs.ssh_keys }}"
          IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.ssh_keys }}"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            if ! doctl compute ssh-key list --format Name --no-header | grep -q "^${key_name}$"; then
              echo "‚ùå Error: SSH key name '${key_name}' not found!"
              echo "Available SSH keys:"
              doctl compute ssh-key list --format ID,Name,Fingerprint
              exit 1
            fi
          done
          echo "‚úÖ All SSH key names are valid"

      - name: Create droplet
        id: create
        run: |
          # Generate unique droplet name
          DROPLET_NAME="gpu-droplet-benchmark-$(date +%s)"
          echo "üöÄ Creating droplet: $DROPLET_NAME"
          
          # Convert SSH key names to IDs and format for doctl
          echo "Converting SSH key names to IDs..."
          SSH_KEY_IDS=""
          IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.ssh_keys }}"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            key_id=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$key_name$" | awk '{print $1}')
            if [ -n "$SSH_KEY_IDS" ]; then
              SSH_KEY_IDS="$SSH_KEY_IDS,$key_id"
            else
              SSH_KEY_IDS="$key_id"
            fi
            echo "  '$key_name' ‚Üí ID: $key_id"
          done
          
          echo ""
          echo "Configuration:"
          echo "  Name: $DROPLET_NAME"
          echo "  Size: ${{ github.event.inputs.slug }}"
          echo "  Region: ${{ github.event.inputs.region }}"
          echo "  Image: ${{ github.event.inputs.image }}"
          echo "  SSH Key Names: ${{ github.event.inputs.ssh_keys }}"
          echo "  SSH Key IDs: $SSH_KEY_IDS"
          echo ""
          
          # Create the droplet
          echo "‚è≥ Creating droplet..."
          if DROPLET_OUTPUT=$(doctl compute droplet create "$DROPLET_NAME" \
            --size "${{ github.event.inputs.slug }}" \
            --region "${{ github.event.inputs.region }}" \
            --image "${{ github.event.inputs.image }}" \
            --ssh-keys $SSH_KEY_IDS \
            --tag-names "gpu-droplet-benchmark,github-actions" \
            --format ID \
            --no-header 2>&1); then
            
            # Extract droplet ID - should be a single line with just the ID
            DROPLET_ID=$(echo "$DROPLET_OUTPUT" | head -n1 | xargs)
            
            # Validate we got a single numeric ID
            if [[ ! "$DROPLET_ID" =~ ^[0-9]+$ ]]; then
              echo "‚ùå ERROR: Invalid droplet ID received: '$DROPLET_ID'"
              echo "Full output was:"
              echo "$DROPLET_OUTPUT"
              exit 1
            fi
            
            echo "üéâ SUCCESS: Droplet created successfully!"
            echo "Droplet ID: $DROPLET_ID"
            echo "Droplet Name: $DROPLET_NAME"
            echo ""
            
            # Get detailed droplet info for display
            echo "üìä Droplet details:"
            doctl compute droplet get "$DROPLET_ID" --format ID,Name,Memory,VCPUs,Disk,Region,Image,Status
            
            # Set outputs for next job
            echo "droplet-id=$DROPLET_ID" >> $GITHUB_OUTPUT
            echo "droplet-name=$DROPLET_NAME" >> $GITHUB_OUTPUT
            echo "success=true" >> $GITHUB_OUTPUT
            
          else
            echo "‚ùå FAILED: Could not create droplet"
            echo "Error details:"
            echo "$DROPLET_OUTPUT"
            
            # Analyze the error
            if echo "$DROPLET_OUTPUT" | grep -i "insufficient\|capacity\|unavailable" > /dev/null; then
              echo ""
              echo "üí° Analysis: No capacity available for this droplet size in region ${{ github.event.inputs.region }}"
            elif echo "$DROPLET_OUTPUT" | grep -i "invalid\|not found" > /dev/null; then
              echo ""
              echo "üí° Analysis: Invalid configuration - check size/region/image combination"
            elif echo "$DROPLET_OUTPUT" | grep -i "limit\|quota" > /dev/null; then
              echo ""
              echo "üí° Analysis: Account limits reached"
            fi
            
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Wait for droplet to be ready
        if: steps.create.outputs.success == 'true'
        run: |
          echo "‚è≥ Waiting for droplet to become active..."
          DROPLET_ID="${{ steps.create.outputs.droplet-id }}"
          
          # Wait up to 5 minutes for droplet to be active
          for i in {1..30}; do
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
            echo "Attempt $i/30: Status is '$STATUS'"
            
            if [ "$STATUS" = "active" ]; then
              echo "‚úÖ Droplet is now active!"
              
              # Get full droplet details
              echo ""
              echo "üìä Final droplet details:"
              doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Memory,VCPUs,Disk,Region,Image,Status
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ö†Ô∏è Droplet did not become active within 5 minutes, but continuing..."
            fi
            
            sleep 10
          done

  health-check:
    runs-on: ubuntu-latest
    needs: create-droplet
    if: needs.create-droplet.outputs.creation-success == 'true'
    outputs:
      health-check-success: ${{ steps.health.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Get droplet IP address
        id: get-ip
        run: |
          DROPLET_ID="${{ needs.create-droplet.outputs.droplet-id }}"
          echo "Getting IP address for droplet $DROPLET_ID..."
          
          # Wait a bit more for IP to be assigned
          sleep 10
          
          PUBLIC_IP=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
          echo "Public IP: $PUBLIC_IP"
          
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "<nil>" ]; then
            echo "‚ùå No public IP assigned yet, waiting..."
            for i in {1..10}; do
              sleep 10
              PUBLIC_IP=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
              echo "Attempt $i: IP is '$PUBLIC_IP'"
              if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "<nil>" ]; then
                break
              fi
            done
          fi
          
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "<nil>" ]; then
            echo "‚ùå Failed to get public IP address"
            exit 1
          fi
          
          echo "‚úÖ Got public IP: $PUBLIC_IP"
          echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the private key from GitHub secrets
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Set SSH options for automated connections
          cat > ~/.ssh/config << EOF
          Host droplet-test
            HostName ${{ steps.get-ip.outputs.public-ip }}
            User root
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ConnectTimeout 30
            ServerAliveInterval 60
          EOF
          
          chmod 600 ~/.ssh/config
          echo "‚úÖ SSH key and config created"

      - name: Wait for SSH to be ready
        run: |
          echo "‚è≥ Waiting for SSH service to be ready..."
          
          # We'll use a simple connection test instead of key-based auth for now
          # This tests if SSH port is open and responding
          for i in {1..30}; do
            echo "Attempt $i/30: Testing SSH connection..."
            if timeout 10 nc -z ${{ steps.get-ip.outputs.public-ip }} 22; then
              echo "‚úÖ SSH port is open!"
              sleep 5  # Give it a moment to fully initialize
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå SSH service did not become ready within 5 minutes"
              exit 1
            fi
            
            sleep 10
          done

      - name: Health check via SSH
        id: health
        run: |
          echo "üè• Starting health check..."
          PUBLIC_IP="${{ steps.get-ip.outputs.public-ip }}"
          HEALTH_SUCCESS=true
          
          echo "Running health checks on $PUBLIC_IP..."
          echo ""
          
          # 1. Docker check
          echo "1. üê≥ Checking Docker installation..."
          if ssh -o ConnectTimeout=30 root@$PUBLIC_IP 'docker --version && docker info > /dev/null 2>&1'; then
            echo "‚úÖ Docker is installed and running"
          else
            echo "‚ùå Docker check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 2. NVIDIA GPU check
          echo "2. üîß Checking NVIDIA GPU drivers..."
          if ssh -o ConnectTimeout=30 root@$PUBLIC_IP 'nvidia-smi'; then
            echo "‚úÖ NVIDIA drivers working and GPU detected"
          else
            echo "‚ùå NVIDIA GPU check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 3. Python and vLLM availability check
          echo "3. üöÄ Checking vLLM availability..."
          if ssh -o ConnectTimeout=30 root@$PUBLIC_IP 'python3 -c "import vllm; print(f\"vLLM version: {vllm.__version__}\")"'; then
            echo "‚úÖ vLLM is available"
          else
            echo "‚ùå vLLM check failed (may not be pre-installed)"
            # Don't fail the health check for vLLM as it might need to be installed
            echo "‚ÑπÔ∏è  vLLM can be installed as needed"
          fi
          echo ""
          
          # 4. GPU-enabled Docker test
          echo "4. üéØ Testing GPU-enabled Docker runtime..."
          if ssh -o ConnectTimeout=60 root@$PUBLIC_IP 'docker run --rm --gpus all nvidia/cuda:12.0-base-ubuntu20.04 nvidia-smi'; then
            echo "‚úÖ GPU-enabled Docker containers work correctly"
          else
            echo "‚ùå GPU Docker runtime check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 5. System resources check
          echo "5. üìä Checking system resources..."
          if ssh -o ConnectTimeout=30 root@$PUBLIC_IP 'df -h / && free -h && uptime'; then
            echo "‚úÖ System resources checked"
          else
            echo "‚ùå System resources check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          if [ "$HEALTH_SUCCESS" = "true" ]; then
            echo "ÔøΩ All critical health checks passed!"
            echo "‚úÖ GPU droplet is ready for vLLM workloads"
          else
            echo "‚ö†Ô∏è Some health checks failed"
            echo "‚ùå GPU droplet may not be fully ready"
          fi
          
          echo "success=$HEALTH_SUCCESS" >> $GITHUB_OUTPUT

      - name: Health check summary
        run: |
          echo "## üè• Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Droplet IP:** \`${{ steps.get-ip.outputs.public-ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Checks Performed:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ SSH connectivity established" >> $GITHUB_STEP_SUMMARY
          echo "- üê≥ Docker installation and service status" >> $GITHUB_STEP_SUMMARY
          echo "- üîß NVIDIA drivers and GPU detection" >> $GITHUB_STEP_SUMMARY  
          echo "- üöÄ vLLM framework availability (optional)" >> $GITHUB_STEP_SUMMARY
          echo "- üéØ GPU-enabled Docker runtime test" >> $GITHUB_STEP_SUMMARY
          echo "- üìä System resources and uptime" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.health.outputs.success }}" = "true" ]; then
            echo "**Status: ‚úÖ ALL CHECKS PASSED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **GPU droplet is ready for vLLM workloads!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ‚ùå SOME CHECKS FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **GPU droplet may need additional setup.**" >> $GITHUB_STEP_SUMMARY
          fi

  # destroy-droplet:
  #   runs-on: ubuntu-latest
  #   needs: [create-droplet, health-check]
  #   if: always() && needs.create-droplet.outputs.creation-success == 'true'
  #   
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Install doctl
  #       uses: digitalocean/action-doctl@v2
  #       with:
  #         token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

  #     - name: Destroy droplet
  #       run: |
  #         DROPLET_ID="${{ needs.create-droplet.outputs.droplet-id }}"
  #         DROPLET_NAME="${{ needs.create-droplet.outputs.droplet-name }}"
  #         
  #         echo "üßπ Destroying test droplet..."
  #         echo "Droplet ID: $DROPLET_ID"
  #         echo "Droplet Name: $DROPLET_NAME"
  #         echo ""
  #         
  #         # Show droplet details before deletion
  #         echo "üìä Current droplet status:"
  #         doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Status || echo "Could not get droplet details"
  #         echo ""
  #         
  #         # Delete the droplet
  #         echo "üóëÔ∏è Deleting droplet..."
  #         if doctl compute droplet delete "$DROPLET_ID" --force; then
  #           echo "‚úÖ Droplet deleted successfully!"
  #           
  #           # Verify deletion
  #           echo ""
  #           echo "üîç Verifying deletion..."
  #           sleep 5
  #           
  #           if doctl compute droplet get "$DROPLET_ID" --format ID --no-header 2>/dev/null; then
  #             echo "‚ö†Ô∏è Droplet still exists, but deletion command succeeded (may take a moment)"
  #           else
  #             echo "‚úÖ Confirmed: Droplet has been completely removed"
  #           fi
  #         else
  #           echo "‚ùå Failed to delete droplet!"
  #           echo "‚ö†Ô∏è IMPORTANT: Manual cleanup may be required!"
  #           echo "Run: doctl compute droplet delete $DROPLET_ID --force"
  #           exit 1
  #         fi

  summary:
    runs-on: ubuntu-latest
    needs: [create-droplet, health-check]
    if: always()
    
    steps:
      - name: Generate workflow summary
        run: |
          echo "## üß™ Droplet Capacity Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Slug:** \`${{ github.event.inputs.slug }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`${{ github.event.inputs.region }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ github.event.inputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **SSH Key Names:** \`${{ github.event.inputs.ssh_keys }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check creation result
          if [ "${{ needs.create-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚úÖ Creation: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet ID:** \`${{ needs.create-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet Name:** \`${{ needs.create-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **Capacity is available!** The droplet was created successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Creation: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **No capacity available** or configuration issue." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check health check result
          if [ "${{ needs.create-droplet.outputs.creation-success }}" = "true" ]; then
            if [ "${{ needs.health-check.outputs.health-check-success }}" = "true" ]; then
              echo "### üè• Health Check: SUCCESS" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ All services (Docker, NVIDIA, vLLM) are ready on the droplet." >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ö†Ô∏è Health Check: FAILED" >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Some services may not be properly configured." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ÑπÔ∏è Health Check: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No droplet was created, so health check was skipped." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check destruction result
          if [ "${{ needs.create-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚ö†Ô∏è Cleanup: DISABLED" >> $GITHUB_STEP_SUMMARY
            echo "üîÑ **Automatic cleanup is currently disabled.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Manual cleanup required:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "doctl compute droplet delete ${{ needs.create-droplet.outputs.droplet-id }} --force" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Droplet Details:**" >> $GITHUB_STEP_SUMMARY
            echo "- **ID:** \`${{ needs.create-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Name:** \`${{ needs.create-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ÑπÔ∏è Cleanup: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No droplet was created, so no cleanup needed." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*This test creates a real droplet to verify capacity, then immediately destroys it.*" >> $GITHUB_STEP_SUMMARY