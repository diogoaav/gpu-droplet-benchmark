name: Test DigitalOcean Droplet Capacity (Real-time)

on:
  workflow_dispatch:
    inputs:
      slug:
        description: 'Droplet slug (e.g., s-1vcpu-1gb, c-2, g-2vcpu-8gb-nvidia-l4)'
        required: true
        type: string
      region:
        description: 'DigitalOcean region (e.g., nyc1, nyc3, sfo3, tor1)'
        required: true
        type: string
      image:
        description: 'Image to test with (e.g., ubuntu-22-04-x64, gpu-h100x8-base)'
        required: false
        type: string
        default: 'ubuntu-22-04-x64'
      ssh_key_ids:
        description: 'SSH Key IDs (comma-separated, optional)'
        required: false
        type: string
      test_method:
        description: 'Testing method'
        required: true
        type: choice
        options:
          - 'create-and-destroy'
          - 'api-check-only'
        default: 'create-and-destroy'

jobs:
  test-capacity:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm init -y
          npm install axios

      - name: Create capacity tester script
        run: |
          cat > capacity-tester.js << 'EOF'
          const axios = require('axios');

          // Configuration
          const DO_API_URL = 'https://api.digitalocean.com/v2';
          const DO_API_TOKEN = process.env.DO_API_TOKEN;

          // Set up Axios instance for DigitalOcean API
          const doClient = axios.create({
            baseURL: DO_API_URL,
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${DO_API_TOKEN}`
            }
          });

          /**
           * Validate inputs using DigitalOcean API
           */
          async function validateInputs(slug, region, image) {
            console.log('üîç Validating inputs...');
            
            // Check region exists and is available
            try {
              const regionsResponse = await doClient.get('/regions');
              const regions = regionsResponse.data.regions;
              const targetRegion = regions.find(r => r.slug === region);
              
              if (!targetRegion) {
                throw new Error(`Region '${region}' not found`);
              }
              
              if (!targetRegion.available) {
                console.log(`‚ö†Ô∏è  Warning: Region '${region}' is marked as unavailable`);
              }
              
              console.log(`‚úÖ Region '${region}' exists (${targetRegion.name})`);
            } catch (error) {
              console.error(`‚ùå Region validation failed: ${error.message}`);
              return false;
            }

            // Check size exists
            try {
              const sizesResponse = await doClient.get('/sizes');
              const sizes = sizesResponse.data.sizes;
              const targetSize = sizes.find(s => s.slug === slug);
              
              if (!targetSize) {
                throw new Error(`Size '${slug}' not found`);
              }
              
              // Check if size is available in the region
              if (!targetSize.regions.includes(region)) {
                console.log(`‚ö†Ô∏è  Warning: Size '${slug}' may not be available in region '${region}'`);
                console.log(`Available regions for this size: ${targetSize.regions.join(', ')}`);
              }
              
              console.log(`‚úÖ Size '${slug}' exists (${targetSize.vcpus} vCPUs, ${targetSize.memory}MB RAM, $${targetSize.price_monthly}/month)`);
            } catch (error) {
              console.error(`‚ùå Size validation failed: ${error.message}`);
              return false;
            }

            // Check image exists
            try {
              const imagesResponse = await doClient.get('/images', {
                params: { type: 'distribution' }
              });
              let targetImage = imagesResponse.data.images.find(i => i.slug === image);
              
              if (!targetImage) {
                // Try application images
                const appImagesResponse = await doClient.get('/images', {
                  params: { type: 'application' }
                });
                targetImage = appImagesResponse.data.images.find(i => i.slug === image);
              }
              
              if (!targetImage) {
                throw new Error(`Image '${image}' not found`);
              }
              
              console.log(`‚úÖ Image '${image}' exists (${targetImage.distribution})`);
            } catch (error) {
              console.error(`‚ùå Image validation failed: ${error.message}`);
              return false;
            }

            return true;
          }

          /**
           * Test capacity by attempting to create a droplet
           */
          async function testCapacityWithCreation(slug, region, image, sshKeys = []) {
            console.log('üß™ Testing capacity with actual droplet creation...');
            
            const testName = `capacity-test-${Date.now()}`;
            
            try {
              const requestBody = {
                name: testName,
                region: region,
                size: slug,
                image: image,
                tags: ['capacity-test', 'auto-delete'],
                ssh_keys: sshKeys
              };

              console.log(`‚è≥ Attempting to create test droplet: ${testName}`);
              
              const startTime = Date.now();
              const response = await doClient.post('/droplets', requestBody);
              const endTime = Date.now();
              
              const droplet = response.data.droplet;
              console.log(`üéâ SUCCESS: Droplet created successfully!`);
              console.log(`   Droplet ID: ${droplet.id}`);
              console.log(`   Name: ${droplet.name}`);
              console.log(`   Status: ${droplet.status}`);
              console.log(`   Creation time: ${endTime - startTime}ms`);
              
              // Wait a moment for the droplet to initialize
              console.log('‚è≥ Waiting 5 seconds before cleanup...');
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Clean up: delete the test droplet
              console.log('üßπ Cleaning up test droplet...');
              await doClient.delete(`/droplets/${droplet.id}`);
              console.log('‚úÖ Test droplet deleted successfully');
              
              return {
                success: true,
                available: true,
                dropletId: droplet.id,
                creationTime: endTime - startTime,
                message: 'Capacity available - droplet created and deleted successfully'
              };
              
            } catch (error) {
              const errorMessage = error.response?.data?.message || error.message;
              const errorId = error.response?.data?.id || 'unknown';
              
              console.log(`‚ùå FAILED: Could not create droplet`);
              console.log(`   Error: ${errorMessage}`);
              console.log(`   Error ID: ${errorId}`);
              
              // Analyze common error patterns
              let analysis = 'Unknown error';
              if (errorMessage.toLowerCase().includes('insufficient') || 
                  errorMessage.toLowerCase().includes('capacity') ||
                  errorMessage.toLowerCase().includes('unavailable')) {
                analysis = 'No capacity available in this region';
              } else if (errorMessage.toLowerCase().includes('invalid') ||
                        errorMessage.toLowerCase().includes('not found')) {
                analysis = 'Invalid configuration (size/region/image combination)';
              } else if (errorMessage.toLowerCase().includes('limit') ||
                        errorMessage.toLowerCase().includes('quota')) {
                analysis = 'Account limits reached';
              }
              
              return {
                success: false,
                available: false,
                error: errorMessage,
                errorId: errorId,
                analysis: analysis,
                message: `Capacity test failed: ${analysis}`
              };
            }
          }

          /**
           * Main function
           */
          async function main() {
            const args = process.argv.slice(2);
            const slug = args[0];
            const region = args[1];
            const image = args[2];
            const testMethod = args[3] || 'create-and-destroy';
            const sshKeyIds = args[4] ? args[4].split(',').map(k => k.trim()) : [];

            console.log('üöÄ DigitalOcean Capacity Tester');
            console.log('================================');
            console.log(`Slug: ${slug}`);
            console.log(`Region: ${region}`);
            console.log(`Image: ${image}`);
            console.log(`Test Method: ${testMethod}`);
            console.log(`SSH Keys: ${sshKeyIds.length > 0 ? sshKeyIds.join(', ') : 'None'}`);
            console.log('');

            // Step 1: Validate inputs
            const isValid = await validateInputs(slug, region, image);
            if (!isValid) {
              console.log('‚ùå Input validation failed. Exiting.');
              process.exit(1);
            }

            console.log('');

            // Step 2: Test capacity
            if (testMethod === 'create-and-destroy') {
              const result = await testCapacityWithCreation(slug, region, image, sshKeyIds);
              
              console.log('');
              console.log('üìä FINAL RESULT:');
              console.log('================');
              console.log(`Status: ${result.available ? '‚úÖ AVAILABLE' : '‚ùå UNAVAILABLE'}`);
              console.log(`Message: ${result.message}`);
              
              if (result.available) {
                console.log(`Creation Time: ${result.creationTime}ms`);
              } else {
                console.log(`Error: ${result.error}`);
                console.log(`Analysis: ${result.analysis}`);
              }
              
              // Set exit code based on availability
              process.exit(result.available ? 0 : 1);
              
            } else {
              console.log('üìã API-only check mode selected');
              console.log('‚úÖ All validations passed - configuration appears valid');
              console.log('‚ÑπÔ∏è  Note: This doesn\'t guarantee real-time capacity availability');
              console.log('   Use "create-and-destroy" method for definitive capacity testing');
            }
          }

          main().catch(error => {
            console.error('üí• Fatal error:', error.message);
            process.exit(1);
          });
          EOF

      - name: Run capacity test
        env:
          DO_API_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
        run: |
          echo "üéØ Starting capacity test..."
          echo "Slug: ${{ github.event.inputs.slug }}"
          echo "Region: ${{ github.event.inputs.region }}"
          echo "Image: ${{ github.event.inputs.image }}"
          echo "Method: ${{ github.event.inputs.test_method }}"
          echo "SSH Keys: ${{ github.event.inputs.ssh_key_ids }}"
          echo ""
          
          node capacity-tester.js \
            "${{ github.event.inputs.slug }}" \
            "${{ github.event.inputs.region }}" \
            "${{ github.event.inputs.image }}" \
            "${{ github.event.inputs.test_method }}" \
            "${{ github.event.inputs.ssh_key_ids }}"

      - name: Generate summary
        if: always()
        run: |
          echo "## üß™ Real-time Capacity Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Configuration Tested:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Droplet Slug:** \`${{ github.event.inputs.slug }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`${{ github.event.inputs.region }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ github.event.inputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Method:** \`${{ github.event.inputs.test_method }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "### ‚úÖ Result: CAPACITY AVAILABLE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **SUCCESS!** Droplet creation test passed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This means:" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ The droplet size is available in the specified region" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ The configuration is valid" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ You can likely provision this droplet type right now" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Result: CAPACITY UNAVAILABLE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **FAILED:** Droplet creation test failed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This could mean:" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ùå No capacity available in this region" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ùå Invalid size/region/image combination" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ùå Account limits reached" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ùå Temporary service issues" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üí° What This Test Does" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.test_method }}" = "create-and-destroy" ]; then
            echo "This test uses the **\"attempt-based detection\"** method:" >> $GITHUB_STEP_SUMMARY
            echo "1. üß™ Attempts to create an actual droplet" >> $GITHUB_STEP_SUMMARY
            echo "2. ‚úÖ If successful ‚Üí Capacity is available" >> $GITHUB_STEP_SUMMARY
            echo "3. üßπ Immediately deletes the test droplet" >> $GITHUB_STEP_SUMMARY
            echo "4. ‚ùå If failed ‚Üí No capacity or configuration issue" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**This provides real-time, definitive availability data!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "This test only validates the configuration without testing real capacity." >> $GITHUB_STEP_SUMMARY
            echo "For definitive capacity testing, use the **\"create-and-destroy\"** method." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- üìä [DigitalOcean Availability Matrix](https://docs.digitalocean.com/products/platform/availability-matrix/)" >> $GITHUB_STEP_SUMMARY
          echo "- ü§ñ [Slug Grabber (Auto-provisioning)](https://github.com/DO-Solutions/slug-grabber)" >> $GITHUB_STEP_SUMMARY
          echo "- üìà [DigitalOcean Pricing](https://www.digitalocean.com/pricing)" >> $GITHUB_STEP_SUMMARY