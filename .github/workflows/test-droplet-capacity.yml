name: GPU Droplet Benchmarking

# Uses SSH_PRIVATE_KEY secret for droplet health checks

on:
  workflow_dispatch:
    inputs:
      # GPU Droplet Configuration
      slug:
        description: 'GPU Droplet size slug (e.g., gpu-h100x1-80gb, gpu-h100x8-640gb)'
        required: true
        type: string
        default: 'gpu-h100x1-80gb'
      region:
        description: 'GPU Droplet region (e.g., nyc1, nyc3, sfo3, tor1)'
        required: true
        type: string
        default: 'tor1'
      image:
        description: 'GPU Droplet image (e.g., gpu-h100x1-base, gpu-h100x8-base)'
        required: true
        type: string
        default: 'gpu-h100x1-base'
      ssh_keys:
        description: 'SSH key names (comma-separated, get with: doctl compute ssh-key list)'
        required: true
        type: string
        default: 'github-actions, macbook'
      
      # CPU Droplet Configuration
      cpu_slug:
        description: 'CPU Droplet size slug (e.g., s-1vcpu-1gb, c-2, m-2vcpu-16gb)'
        required: true
        type: string
        default: 'c-2'
      cpu_region:
        description: 'CPU Droplet region (e.g., nyc1, nyc3, sfo3, tor1)'
        required: true
        type: string
        default: 'tor1'
      cpu_image:
        description: 'CPU Droplet image (e.g., ubuntu-22-04-x64, ubuntu-24-04-x64)'
        required: true
        type: string
        default: 'ubuntu-24-04-x64'
      cpu_ssh_keys:
        description: 'CPU SSH key names (comma-separated, get with: doctl compute ssh-key list)'
        required: true
        type: string
        default: 'github-actions, macbook'

jobs:
  create-gpu-droplet:
    runs-on: ubuntu-latest
    outputs:
      droplet-id: ${{ steps.create.outputs.droplet-id }}
      droplet-name: ${{ steps.create.outputs.droplet-name }}
      creation-success: ${{ steps.create.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Validate inputs
        run: |
          echo "üîç Validating inputs..."
          
          # Check if region exists
          echo "Checking region: ${{ github.event.inputs.region }}"
          if ! doctl compute region list --format Slug --no-header | grep -q "^${{ github.event.inputs.region }}$"; then
            echo "‚ùå Error: Region '${{ github.event.inputs.region }}' not found!"
            echo "Available regions:"
            doctl compute region list --format Slug,Name,Available
            exit 1
          fi
          echo "‚úÖ Region '${{ github.event.inputs.region }}' is valid"
          
          # Check if size exists
          echo "Checking droplet size: ${{ github.event.inputs.slug }}"
          if ! doctl compute size list --format Slug --no-header | grep -q "^${{ github.event.inputs.slug }}$"; then
            echo "‚ùå Error: Droplet size '${{ github.event.inputs.slug }}' not found!"
            echo "Available sizes:"
            doctl compute size list --format Slug,Memory,VCPUs,Disk,PriceMonthly
            exit 1
          fi
          echo "‚úÖ Droplet size '${{ github.event.inputs.slug }}' is valid"
          
          # Validate SSH keys
          echo "Validating SSH keys: ${{ github.event.inputs.ssh_keys }}"
          IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.ssh_keys }}"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            if ! doctl compute ssh-key list --format Name --no-header | grep -q "^${key_name}$"; then
              echo "‚ùå Error: SSH key name '${key_name}' not found!"
              echo "Available SSH keys:"
              doctl compute ssh-key list --format ID,Name,Fingerprint
              exit 1
            fi
          done
          echo "‚úÖ All SSH key names are valid"

      - name: Create droplet
        id: create
        run: |
          # Generate unique droplet name
          DROPLET_NAME="gpu-droplet-benchmark-$(date +%s)"
          echo "üöÄ Creating droplet: $DROPLET_NAME"
          
          # Convert SSH key names to IDs and format for doctl
          echo "Converting SSH key names to IDs..."
          SSH_KEY_IDS=""
          IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.ssh_keys }}"
          for key_name in "${SSH_KEYS[@]}"; do
            key_name=$(echo "$key_name" | xargs) # trim whitespace
            key_id=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$key_name$" | awk '{print $1}')
            if [ -n "$SSH_KEY_IDS" ]; then
              SSH_KEY_IDS="$SSH_KEY_IDS,$key_id"
            else
              SSH_KEY_IDS="$key_id"
            fi
            echo "  '$key_name' ‚Üí ID: $key_id"
          done
          
          echo ""
          echo "Configuration:"
          echo "  Name: $DROPLET_NAME"
          echo "  Size: ${{ github.event.inputs.slug }}"
          echo "  Region: ${{ github.event.inputs.region }}"
          echo "  Image: ${{ github.event.inputs.image }}"
          echo "  SSH Key Names: ${{ github.event.inputs.ssh_keys }}"
          echo "  SSH Key IDs: $SSH_KEY_IDS"
          echo ""
          
          # Create the droplet
          echo "‚è≥ Creating droplet..."
          if DROPLET_OUTPUT=$(doctl compute droplet create "$DROPLET_NAME" \
            --size "${{ github.event.inputs.slug }}" \
            --region "${{ github.event.inputs.region }}" \
            --image "${{ github.event.inputs.image }}" \
            --ssh-keys $SSH_KEY_IDS \
            --tag-names "gpu-droplet-benchmark,github-actions" \
            --format ID \
            --no-header 2>&1); then
            
            # Extract droplet ID - should be a single line with just the ID
            DROPLET_ID=$(echo "$DROPLET_OUTPUT" | head -n1 | xargs)
            
            # Validate we got a single numeric ID
            if [[ ! "$DROPLET_ID" =~ ^[0-9]+$ ]]; then
              echo "‚ùå ERROR: Invalid droplet ID received: '$DROPLET_ID'"
              echo "Full output was:"
              echo "$DROPLET_OUTPUT"
              exit 1
            fi
            
            echo "üéâ SUCCESS: Droplet created successfully!"
            echo "Droplet ID: $DROPLET_ID"
            echo "Droplet Name: $DROPLET_NAME"
            echo ""
            
            # Get detailed droplet info for display
            echo "üìä Droplet details:"
            doctl compute droplet get "$DROPLET_ID" --format ID,Name,Memory,VCPUs,Disk,Region,Image,Status
            
            # Set outputs for next job
            echo "droplet-id=$DROPLET_ID" >> $GITHUB_OUTPUT
            echo "droplet-name=$DROPLET_NAME" >> $GITHUB_OUTPUT
            echo "success=true" >> $GITHUB_OUTPUT
            
          else
            echo "‚ùå FAILED: Could not create droplet"
            echo "Error details:"
            echo "$DROPLET_OUTPUT"
            
            # Analyze the error
            if echo "$DROPLET_OUTPUT" | grep -i "insufficient\|capacity\|unavailable" > /dev/null; then
              echo ""
              echo "üí° Analysis: No capacity available for this droplet size in region ${{ github.event.inputs.region }}"
            elif echo "$DROPLET_OUTPUT" | grep -i "invalid\|not found" > /dev/null; then
              echo ""
              echo "üí° Analysis: Invalid configuration - check size/region/image combination"
            elif echo "$DROPLET_OUTPUT" | grep -i "limit\|quota" > /dev/null; then
              echo ""
              echo "üí° Analysis: Account limits reached"
            fi
            
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Wait for droplet to be ready
        if: steps.create.outputs.success == 'true'
        run: |
          echo "‚è≥ Waiting for droplet to become active..."
          DROPLET_ID="${{ steps.create.outputs.droplet-id }}"
          
          # Wait up to 5 minutes for droplet to be active
          for i in {1..30}; do
            STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
            echo "Attempt $i/30: Status is '$STATUS'"
            
            if [ "$STATUS" = "active" ]; then
              echo "‚úÖ Droplet is now active!"
              
              # Get full droplet details
              echo ""
              echo "üìä Final droplet details:"
              doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Memory,VCPUs,Disk,Region,Image,Status
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ö†Ô∏è Droplet did not become active within 5 minutes, but continuing..."
            fi
            
            sleep 10
          done

  # create-cpu-droplet:
  #   runs-on: ubuntu-latest
  #   outputs:
  #     droplet-id: ${{ steps.create.outputs.droplet-id }}
  #     droplet-name: ${{ steps.create.outputs.droplet-name }}
  #     creation-success: ${{ steps.create.outputs.success }}
  #   
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Install doctl
  #       uses: digitalocean/action-doctl@v2
  #       with:
  #         token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

  #     - name: Validate CPU droplet inputs
  #       run: |
  #         echo "üîç Validating CPU droplet inputs..."
  #         
  #         # Check if CPU region exists
  #         echo "Checking CPU region: ${{ github.event.inputs.cpu_region }}"
  #         if ! doctl compute region list --format Slug --no-header | grep -q "^${{ github.event.inputs.cpu_region }}$"; then
  #           echo "‚ùå Error: CPU Region '${{ github.event.inputs.cpu_region }}' not found!"
  #           echo "Available regions:"
  #           doctl compute region list --format Slug,Name,Available
  #           exit 1
  #         fi
  #         echo "‚úÖ CPU Region '${{ github.event.inputs.cpu_region }}' is valid"
  #         
  #         # Check if CPU size exists
  #         echo "Checking CPU droplet size: ${{ github.event.inputs.cpu_slug }}"
  #         if ! doctl compute size list --format Slug --no-header | grep -q "^${{ github.event.inputs.cpu_slug }}$"; then
  #           echo "‚ùå Error: CPU Droplet size '${{ github.event.inputs.cpu_slug }}' not found!"
  #           echo "Available sizes:"
  #           doctl compute size list --format Slug,Memory,VCPUs,Disk,PriceMonthly
  #           exit 1
  #         fi
  #         echo "‚úÖ CPU Droplet size '${{ github.event.inputs.cpu_slug }}' is valid"
  #         
  #         # Validate CPU SSH keys
  #         echo "Validating CPU SSH keys: ${{ github.event.inputs.cpu_ssh_keys }}"
  #         IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.cpu_ssh_keys }}"
  #         for key_name in "${SSH_KEYS[@]}"; do
  #           key_name=$(echo "$key_name" | xargs) # trim whitespace
  #           if ! doctl compute ssh-key list --format Name --no-header | grep -q "^${key_name}$"; then
  #             echo "‚ùå Error: CPU SSH key name '${key_name}' not found!"
  #             echo "Available SSH keys:"
  #             doctl compute ssh-key list --format ID,Name,Fingerprint
  #             exit 1
  #           fi
  #         done
  #         echo "‚úÖ All CPU SSH key names are valid"

  #     - name: Create CPU droplet
  #       id: create
  #       run: |
  #         # Generate unique droplet name
  #         DROPLET_NAME="cpu-droplet-benchmark-$(date +%s)"
  #         echo "üöÄ Creating CPU droplet: $DROPLET_NAME"
  #         
  #         # Convert SSH key names to IDs for CPU droplet
  #         echo "Converting SSH key names to IDs..."
  #         SSH_KEY_IDS=""
  #         IFS=',' read -ra SSH_KEYS <<< "${{ github.event.inputs.cpu_ssh_keys }}"
  #         for key_name in "${SSH_KEYS[@]}"; do
  #           key_name=$(echo "$key_name" | xargs) # trim whitespace
  #           key_id=$(doctl compute ssh-key list --format ID,Name --no-header | grep "$key_name$" | awk '{print $1}')
  #           if [ -n "$SSH_KEY_IDS" ]; then
  #             SSH_KEY_IDS="$SSH_KEY_IDS,$key_id"
  #           else
  #             SSH_KEY_IDS="$key_id"
  #           fi
  #           echo "  '$key_name' ‚Üí ID: $key_id"
  #         done
  #         
  #         echo ""
  #         echo "CPU Droplet Configuration:"
  #         echo "  Name: $DROPLET_NAME"
  #         echo "  Size: ${{ github.event.inputs.cpu_slug }}"
  #         echo "  Region: ${{ github.event.inputs.cpu_region }}"
  #         echo "  Image: ${{ github.event.inputs.cpu_image }}"
  #         echo "  SSH Key Names: ${{ github.event.inputs.cpu_ssh_keys }}"
  #         echo "  SSH Key IDs: $SSH_KEY_IDS"
  #         echo ""
  #         
  #         # Create the CPU droplet
  #         echo "‚è≥ Creating CPU droplet..."
  #         if DROPLET_OUTPUT=$(doctl compute droplet create "$DROPLET_NAME" \
  #           --size "${{ github.event.inputs.cpu_slug }}" \
  #           --region "${{ github.event.inputs.cpu_region }}" \
  #           --image "${{ github.event.inputs.cpu_image }}" \
  #           --ssh-keys $SSH_KEY_IDS \
  #           --tag-names "cpu-droplet-benchmark,github-actions" \
  #           --format ID \
  #           --no-header 2>&1); then
  #           
  #           # Extract droplet ID - should be a single line with just the ID
  #           DROPLET_ID=$(echo "$DROPLET_OUTPUT" | head -n1 | xargs)
  #           
  #           # Validate we got a single numeric ID
  #           if [[ ! "$DROPLET_ID" =~ ^[0-9]+$ ]]; then
  #             echo "‚ùå ERROR: Invalid droplet ID received: '$DROPLET_ID'"
  #             echo "Full output was:"
  #             echo "$DROPLET_OUTPUT"
  #             exit 1
  #           fi
  #           
  #           echo "üéâ SUCCESS: CPU Droplet created successfully!"
  #           echo "Droplet ID: $DROPLET_ID"
  #           echo "Droplet Name: $DROPLET_NAME"
  #           echo ""
  #           
  #           # Get detailed droplet info for display
  #           echo "üìä CPU Droplet details:"
  #           doctl compute droplet get "$DROPLET_ID" --format ID,Name,Memory,VCPUs,Disk,Region,Image,Status
  #           
  #           # Set outputs for next job
  #           echo "droplet-id=$DROPLET_ID" >> $GITHUB_OUTPUT
  #           echo "droplet-name=$DROPLET_NAME" >> $GITHUB_OUTPUT
  #           echo "success=true" >> $GITHUB_OUTPUT
  #           
  #         else
  #           echo "‚ùå FAILED: Could not create CPU droplet"
  #           echo "Error details:"
  #           echo "$DROPLET_OUTPUT"
  #           
  #           # Analyze the error
  #           if echo "$DROPLET_OUTPUT" | grep -i "insufficient\|capacity\|unavailable" > /dev/null; then
  #             echo ""
  #             echo "üí° Analysis: No capacity available for CPU droplet in region ${{ github.event.inputs.cpu_region }}"
  #           elif echo "$DROPLET_OUTPUT" | grep -i "invalid\|not found" > /dev/null; then
  #             echo ""
  #             echo "üí° Analysis: Invalid configuration - check size/region/image combination"
  #           elif echo "$DROPLET_OUTPUT" | grep -i "limit\|quota" > /dev/null; then
  #             echo ""
  #             echo "üí° Analysis: Account limits reached"
  #           fi
  #           
  #           echo "success=false" >> $GITHUB_OUTPUT
  #           exit 1
  #         fi

  #   - name: Wait for CPU droplet to be ready
  #     if: steps.create.outputs.success == 'true'
  #     run: |
  #       echo "‚è≥ Waiting for CPU droplet to become active..."
  #       DROPLET_ID="${{ steps.create.outputs.droplet-id }}"
  #       
  #       # Wait up to 5 minutes for droplet to be active
  #       for i in {1..30}; do
  #         STATUS=$(doctl compute droplet get "$DROPLET_ID" --format Status --no-header)
  #         echo "Attempt $i/30: Status is '$STATUS'"
  #         
  #         if [ "$STATUS" = "active" ]; then
  #           echo "‚úÖ CPU Droplet is now active!"
  #           
  #           # Get full droplet details
  #           echo ""
  #           echo "üìä Final CPU droplet details:"
  #           doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Memory,VCPUs,Disk,Region,Image,Status
  #           break
  #         fi
  #         
  #         if [ $i -eq 30 ]; then
  #           echo "‚ö†Ô∏è CPU Droplet did not become active within 5 minutes, but continuing..."
  #         fi
  #         
  #         sleep 10
  #       done

  health-check:
    runs-on: ubuntu-latest
    needs: create-gpu-droplet
    if: needs.create-gpu-droplet.outputs.creation-success == 'true'
    outputs:
      health-check-success: ${{ steps.health.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Get droplet IP address
        id: get-ip
        run: |
          DROPLET_ID="${{ needs.create-gpu-droplet.outputs.droplet-id }}"
          echo "Getting IP address for droplet $DROPLET_ID..."
          
          # Wait a bit more for IP to be assigned
          sleep 10
          
          PUBLIC_IP=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
          echo "Public IP: $PUBLIC_IP"
          
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "<nil>" ]; then
            echo "‚ùå No public IP assigned yet, waiting..."
            for i in {1..10}; do
              sleep 10
              PUBLIC_IP=$(doctl compute droplet get "$DROPLET_ID" --format PublicIPv4 --no-header)
              echo "Attempt $i: IP is '$PUBLIC_IP'"
              if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "<nil>" ]; then
                break
              fi
            done
          fi
          
          if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "<nil>" ]; then
            echo "‚ùå Failed to get public IP address"
            exit 1
          fi
          
          echo "‚úÖ Got public IP: $PUBLIC_IP"
          echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the private key from GitHub secrets
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Set SSH options for automated connections
          cat > ~/.ssh/config << EOF
          Host droplet-test
            HostName ${{ steps.get-ip.outputs.public-ip }}
            User root
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ConnectTimeout 30
            ServerAliveInterval 60
          EOF
          
          chmod 600 ~/.ssh/config
          echo "‚úÖ SSH key and config created"

      - name: Wait for SSH to be ready
        run: |
          echo "‚è≥ Waiting for SSH service to be ready..."
          PUBLIC_IP="${{ steps.get-ip.outputs.public-ip }}"
          
          # Debug SSH setup
          echo "üîç SSH setup verification:"
          echo "Private key exists: $([ -f ~/.ssh/id_rsa ] && echo 'YES' || echo 'NO')"
          echo "Private key permissions: $(stat -c %a ~/.ssh/id_rsa 2>/dev/null || echo 'N/A')"
          echo "SSH config exists: $([ -f ~/.ssh/config ] && echo 'YES' || echo 'NO')"
          echo ""
          
          # Test actual SSH connectivity with key authentication
          for i in {1..30}; do
            echo "Attempt $i/30: Testing SSH connection..."
            if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 root@$PUBLIC_IP 'echo "SSH connection successful"' 2>/dev/null; then
              echo "‚úÖ SSH connection established!"
              sleep 2  # Give it a moment to fully initialize
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå SSH service did not become ready within 5 minutes"
              echo "üîç Final SSH debug attempt:"
              ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -v root@$PUBLIC_IP 'echo "Debug connection"' || true
              exit 1
            fi
            
            sleep 10
          done

      - name: Health check via SSH
        id: health
        run: |
          echo "üè• Starting health check..."
          PUBLIC_IP="${{ steps.get-ip.outputs.public-ip }}"
          HEALTH_SUCCESS=true
          
          echo "Running health checks on $PUBLIC_IP..."
          echo ""
          
          # Debug SSH connection
          echo "üîç Testing SSH connection first..."
          ssh -F ~/.ssh/config -o ConnectTimeout=10 droplet-test 'echo "SSH test successful"' || {
            echo "‚ùå SSH connection failed, trying direct connection..."
            ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 root@$PUBLIC_IP 'echo "Direct SSH test successful"'
          }
          echo ""
          
          # 1. Docker check
          echo "1. üê≥ Checking Docker installation..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'docker --version && docker info > /dev/null 2>&1'; then
            echo "‚úÖ Docker is installed and running"
          else
            echo "‚ùå Docker check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 2. NVIDIA GPU check
          echo "2. üîß Checking NVIDIA GPU drivers..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'nvidia-smi'; then
            echo "‚úÖ NVIDIA drivers working and GPU detected"
          else
            echo "‚ùå NVIDIA GPU check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 3. NVIDIA Container Toolkit check
          echo "3. ÔøΩ Checking NVIDIA Container Toolkit availability..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'nvidia-ctk --version && docker info | grep -i nvidia'; then
            echo "‚úÖ NVIDIA Container Toolkit is available"
          else
            echo "‚ùå NVIDIA Container Toolkit not found (may need installation)"
            # Don't fail health check as this can be installed later
            echo "‚ÑπÔ∏è  Can be installed via setup-dependencies job"
          fi
          echo ""
          
          # 4. GPU-enabled Docker runtime test
          echo "4. üéØ Testing GPU access in Docker containers..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=60 root@$PUBLIC_IP 'docker run --rm --gpus all nvidia/cuda:12.0-base-ubuntu20.04 nvidia-smi'; then
            echo "‚úÖ GPU-enabled Docker containers work correctly"
          else
            echo "‚ùå GPU Docker runtime check failed"
            echo "‚ÑπÔ∏è  This may work after installing NVIDIA Container Toolkit"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          # 5. System resources check
          echo "5. üìä Checking system resources..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30 root@$PUBLIC_IP 'df -h / && free -h && uptime'; then
            echo "‚úÖ System resources checked"
          else
            echo "‚ùå System resources check failed"
            HEALTH_SUCCESS=false
          fi
          echo ""
          
          if [ "$HEALTH_SUCCESS" = "true" ]; then
            echo "üéâ All critical health checks passed!"
            echo "‚úÖ GPU droplet is ready for containerized workloads"
          else
            echo "‚ö†Ô∏è Some health checks failed"
            echo "‚ùå GPU droplet may need additional setup for GPU containers"
          fi
          
          echo "success=$HEALTH_SUCCESS" >> $GITHUB_OUTPUT

      - name: Health check summary
        run: |
          echo "## üè• Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Droplet IP:** \`${{ steps.get-ip.outputs.public-ip }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Checks Performed:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ SSH connectivity established" >> $GITHUB_STEP_SUMMARY
          echo "- üê≥ Docker installation and service status" >> $GITHUB_STEP_SUMMARY
          echo "- üîß NVIDIA drivers and GPU detection" >> $GITHUB_STEP_SUMMARY  
          echo "- ÔøΩ NVIDIA Container Toolkit availability (optional)" >> $GITHUB_STEP_SUMMARY
          echo "- üéØ GPU access in Docker containers" >> $GITHUB_STEP_SUMMARY
          echo "- üìä System resources and uptime" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.health.outputs.success }}" = "true" ]; then
            echo "**Status: ‚úÖ ALL CHECKS PASSED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **GPU droplet is ready for containerized GPU workloads!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ‚ùå SOME CHECKS FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **GPU droplet may need additional setup.**" >> $GITHUB_STEP_SUMMARY
          fi

  setup-dependencies:
    runs-on: ubuntu-latest
    needs: [create-gpu-droplet, health-check]
    if: needs.create-gpu-droplet.outputs.creation-success == 'true'
    outputs:
      setup-success: ${{ steps.setup.outputs.success }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write the private key from GitHub secrets
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Setup missing dependencies
        id: setup
        run: |
          echo "üîß Setting up NVIDIA Container Toolkit for GPU containers..."
          PUBLIC_IP=$(doctl compute droplet get "${{ needs.create-gpu-droplet.outputs.droplet-id }}" --format PublicIPv4 --no-header)
          SETUP_SUCCESS=true
          
          echo "Setting up GPU container support on $PUBLIC_IP..."
          echo ""
          
          # 1. Setup NVIDIA Container Toolkit for Docker
          echo "1. üê≥ Setting up NVIDIA Container Toolkit..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=120 root@$PUBLIC_IP '
            echo "Installing NVIDIA Container Toolkit..."
            
            # Wait for any existing apt processes to complete
            echo "Waiting for package manager to be available..."
            while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
              echo "Waiting for apt lock to be released..."
              sleep 5
            done
            
            # Add NVIDIA package repository
            curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
            curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \
              sed "s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g" | \
              tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
            
            # Install NVIDIA Container Toolkit with retry logic
            for i in {1..3}; do
              if apt-get update -qq && apt-get install -y nvidia-container-toolkit; then
                break
              else
                echo "Attempt $i failed, retrying in 10 seconds..."
                sleep 10
              fi
            done
            
            # Configure Docker to use NVIDIA runtime
            nvidia-ctk runtime configure --runtime=docker
            systemctl restart docker
            
            echo "NVIDIA Container Toolkit setup completed"
          '; then
            echo "‚úÖ NVIDIA Container Toolkit installed successfully"
          else
            echo "‚ùå NVIDIA Container Toolkit installation failed"
            SETUP_SUCCESS=false
          fi
          echo ""
          
          # 2. Test GPU Docker with CUDA runtime
          echo "2. üéØ Testing GPU-enabled Docker with CUDA runtime..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=120 root@$PUBLIC_IP '
            echo "Testing GPU Docker runtime..."
            # Wait for Docker daemon to restart after NVIDIA runtime configuration
            sleep 10
            docker run --rm --gpus all nvidia/cuda:12.0-base-ubuntu22.04 nvidia-smi
          '; then
            echo "‚úÖ GPU Docker runtime working correctly"
          else
            echo "‚ö†Ô∏è GPU Docker test failed, but toolkit is installed"
            echo "‚ÑπÔ∏è  This may work after a brief delay for Docker to fully restart"
          fi
          echo ""
          
          # 3. Test vLLM container (optional - demonstrates containerized ML workload)
          echo "3. ü§ñ Testing vLLM container capability..."
          if ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=120 root@$PUBLIC_IP '
            echo "Testing vLLM container with GPU access..."
            # Test vLLM container by overriding entrypoint to run Python directly
            docker run --rm --gpus all --entrypoint python vllm/vllm-openai:latest -c "import vllm; print(f\"vLLM container version: {vllm.__version__}\")"
          '; then
            echo "‚úÖ vLLM container working with GPU access"
          else
            echo "‚ö†Ô∏è vLLM container test failed (may need longer startup time)"
            echo "‚ÑπÔ∏è  NVIDIA Container Toolkit is installed and basic GPU access works"
          fi
          echo ""
          
          if [ "$SETUP_SUCCESS" = "true" ]; then
            echo "üéâ GPU container runtime setup completed!"
            echo "‚úÖ GPU droplet is now ready for containerized ML workloads"
          else
            echo "‚ö†Ô∏è Container toolkit installation failed"
            echo "‚ùå Manual intervention may be required"
          fi
          
          echo "success=$SETUP_SUCCESS" >> $GITHUB_OUTPUT

      - name: Setup summary
        run: |
          echo "## üîß GPU Container Runtime Setup Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Components Installed:" >> $GITHUB_STEP_SUMMARY
          echo "- üê≥ **NVIDIA Container Toolkit** - GPU support for Docker containers (with APT lock handling)" >> $GITHUB_STEP_SUMMARY
          echo "- üéØ **GPU Docker Runtime** - Tested with nvidia/cuda:12.0-base-ubuntu22.04 image" >> $GITHUB_STEP_SUMMARY
          echo "- ü§ñ **vLLM Container Support** - Tested containerized ML workload with proper entrypoint" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Container-First Approach:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **No host Python dependencies** - All ML workloads run in containers" >> $GITHUB_STEP_SUMMARY
          echo "- üîí **Isolated environments** - Clean separation of workloads" >> $GITHUB_STEP_SUMMARY
          echo "- üöÄ **Ready for production** - Consistent runtime across environments" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.setup.outputs.success }}" = "true" ]; then
            echo "**Status: ‚úÖ SETUP SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **GPU droplet ready for containerized ML workloads!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ‚ùå SETUP ISSUES**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **Container toolkit installation failed. Check logs for details.**" >> $GITHUB_STEP_SUMMARY
          fi

  # destroy-cpu-droplet:
  #   runs-on: ubuntu-latest
  #   needs: [create-cpu-droplet]
  #   if: always() && needs.create-cpu-droplet.outputs.creation-success == 'true'
  #   
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4
  #
  #     - name: Install doctl
  #       uses: digitalocean/action-doctl@v2
  #       with:
  #         token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
  #
  #     - name: Destroy CPU droplet
  #       run: |
  #         DROPLET_ID="${{ needs.create-cpu-droplet.outputs.droplet-id }}"
  #         DROPLET_NAME="${{ needs.create-cpu-droplet.outputs.droplet-name }}"
  #         
  #         echo "üßπ Destroying CPU test droplet..."
  #         echo "Droplet ID: $DROPLET_ID"
  #         echo "Droplet Name: $DROPLET_NAME"
  #         echo ""
  #         
  #         # Show droplet details before deletion
  #         echo "üìä Current CPU droplet status:"
  #         doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Status || echo "Could not get droplet details"
  #         echo ""
  #         
  #         # Delete the droplet
  #         echo "üóëÔ∏è Deleting CPU droplet..."
  #         if doctl compute droplet delete "$DROPLET_ID" --force; then
  #           echo "‚úÖ CPU Droplet deleted successfully!"
  #           
  #           # Verify deletion
  #           echo ""
  #           echo "üîç Verifying deletion..."
  #           sleep 5
  #           
  #           if doctl compute droplet get "$DROPLET_ID" --format ID --no-header 2>/dev/null; then
  #             echo "‚ö†Ô∏è CPU Droplet still exists, but deletion command succeeded (may take a moment)"
  #           else
  #             echo "‚úÖ Confirmed: CPU Droplet has been completely removed"
  #           fi
  #         else
  #           echo "‚ùå Failed to delete CPU droplet!"
  #           echo "‚ö†Ô∏è IMPORTANT: Manual cleanup may be required!"
  #           echo "Run: doctl compute droplet delete $DROPLET_ID --force"
  #           exit 1
  #         fi

  # destroy-droplet:
  #   runs-on: ubuntu-latest
  #   needs: [create-droplet, health-check]
  #   if: always() && needs.create-droplet.outputs.creation-success == 'true'
  #   
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Install doctl
  #       uses: digitalocean/action-doctl@v2
  #       with:
  #         token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

  #     - name: Destroy droplet
  #       run: |
  #         DROPLET_ID="${{ needs.create-droplet.outputs.droplet-id }}"
  #         DROPLET_NAME="${{ needs.create-droplet.outputs.droplet-name }}"
  #         
  #         echo "üßπ Destroying test droplet..."
  #         echo "Droplet ID: $DROPLET_ID"
  #         echo "Droplet Name: $DROPLET_NAME"
  #         echo ""
  #         
  #         # Show droplet details before deletion
  #         echo "üìä Current droplet status:"
  #         doctl compute droplet get "$DROPLET_ID" --format ID,Name,PublicIPv4,Status || echo "Could not get droplet details"
  #         echo ""
  #         
  #         # Delete the droplet
  #         echo "üóëÔ∏è Deleting droplet..."
  #         if doctl compute droplet delete "$DROPLET_ID" --force; then
  #           echo "‚úÖ Droplet deleted successfully!"
  #           
  #           # Verify deletion
  #           echo ""
  #           echo "üîç Verifying deletion..."
  #           sleep 5
  #           
  #           if doctl compute droplet get "$DROPLET_ID" --format ID --no-header 2>/dev/null; then
  #             echo "‚ö†Ô∏è Droplet still exists, but deletion command succeeded (may take a moment)"
  #           else
  #             echo "‚úÖ Confirmed: Droplet has been completely removed"
  #           fi
  #         else
  #           echo "‚ùå Failed to delete droplet!"
  #           echo "‚ö†Ô∏è IMPORTANT: Manual cleanup may be required!"
  #           echo "Run: doctl compute droplet delete $DROPLET_ID --force"
  #           exit 1
  #         fi

  summary:
    runs-on: ubuntu-latest
    needs: [create-gpu-droplet, health-check, setup-dependencies]
    if: always()
    
    steps:
      - name: Generate workflow summary
        run: |
          echo "## üß™ Droplet Capacity Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**GPU Droplet Configuration:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Slug:** \`${{ github.event.inputs.slug }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** \`${{ github.event.inputs.region }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** \`${{ github.event.inputs.image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **SSH Key Names:** \`${{ github.event.inputs.ssh_keys }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # echo "**CPU Droplet Configuration:**" >> $GITHUB_STEP_SUMMARY
          # echo "- **Slug:** \`${{ github.event.inputs.cpu_slug }}\`" >> $GITHUB_STEP_SUMMARY
          # echo "- **Region:** \`${{ github.event.inputs.cpu_region }}\`" >> $GITHUB_STEP_SUMMARY
          # echo "- **Image:** \`${{ github.event.inputs.cpu_image }}\`" >> $GITHUB_STEP_SUMMARY
          # echo "- **SSH Key Names:** \`${{ github.event.inputs.cpu_ssh_keys }}\`" >> $GITHUB_STEP_SUMMARY
          # echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check GPU creation result
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚úÖ GPU Creation: SUCCESS" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet ID:** \`${{ needs.create-gpu-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Droplet Name:** \`${{ needs.create-gpu-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **GPU Capacity is available!** The GPU droplet was created successfully." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå GPU Creation: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **No GPU capacity available** or configuration issue." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # # Check CPU creation result
          # if [ "${{ needs.create-cpu-droplet.outputs.creation-success }}" = "true" ]; then
          #   echo "### ‚úÖ CPU Creation: SUCCESS" >> $GITHUB_STEP_SUMMARY
          #   echo "- **Droplet ID:** \`${{ needs.create-cpu-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
          #   echo "- **Droplet Name:** \`${{ needs.create-cpu-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
          #   echo "" >> $GITHUB_STEP_SUMMARY
          #   echo "üéâ **CPU Capacity is available!** The CPU droplet was created successfully." >> $GITHUB_STEP_SUMMARY
          # else
          #   echo "### ‚ùå CPU Creation: FAILED" >> $GITHUB_STEP_SUMMARY
          #   echo "" >> $GITHUB_STEP_SUMMARY
          #   echo "‚ö†Ô∏è **No CPU capacity available** or configuration issue." >> $GITHUB_STEP_SUMMARY
          # fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check health check result (GPU only)
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            if [ "${{ needs.health-check.outputs.health-check-success }}" = "true" ]; then
              echo "### üè• GPU Health Check: SUCCESS" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ All core services (Docker, NVIDIA drivers, GPU containers) are ready on the GPU droplet." >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ö†Ô∏è GPU Health Check: FAILED" >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Some services may not be properly configured on GPU droplet." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ÑπÔ∏è GPU Health Check: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No GPU droplet was created, so health check was skipped." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check setup result (GPU only)
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            if [ "${{ needs.setup-dependencies.outputs.setup-success }}" = "true" ]; then
              echo "### üîß GPU Dependency Setup: SUCCESS" >> $GITHUB_STEP_SUMMARY
              echo "‚úÖ All missing components (vLLM, NVIDIA Container Toolkit) installed successfully on GPU droplet." >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.setup-dependencies.result }}" = "failure" ]; then
              echo "### ‚ùå GPU Dependency Setup: FAILED" >> $GITHUB_STEP_SUMMARY
              echo "‚ùå Some dependencies failed to install properly on GPU droplet." >> $GITHUB_STEP_SUMMARY
            else
              echo "### ‚ö†Ô∏è GPU Dependency Setup: SKIPPED" >> $GITHUB_STEP_SUMMARY
              echo "‚ÑπÔ∏è Setup job was skipped or didn't run." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### ‚ÑπÔ∏è GPU Dependency Setup: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No GPU droplet was created, so setup was skipped." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # # Check CPU destruction result
          # if [ "${{ needs.create-cpu-droplet.outputs.creation-success }}" = "true" ]; then
          #   if [ "${{ needs.destroy-cpu-droplet.result }}" = "success" ]; then
          #     echo "### ‚úÖ CPU Cleanup: SUCCESS" >> $GITHUB_STEP_SUMMARY
          #     echo "üßπ **CPU droplet was automatically destroyed.**" >> $GITHUB_STEP_SUMMARY
          #   else
          #     echo "### ‚ùå CPU Cleanup: FAILED" >> $GITHUB_STEP_SUMMARY
          #     echo "‚ö†Ô∏è **CPU droplet cleanup failed. Manual cleanup required:**" >> $GITHUB_STEP_SUMMARY
          #     echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          #     echo "doctl compute droplet delete ${{ needs.create-cpu-droplet.outputs.droplet-id }} --force" >> $GITHUB_STEP_SUMMARY
          #     echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          #   fi
          # else
          #   echo "### ‚ÑπÔ∏è CPU Cleanup: SKIPPED" >> $GITHUB_STEP_SUMMARY
          #   echo "No CPU droplet was created, so no cleanup needed." >> $GITHUB_STEP_SUMMARY
          # fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check GPU destruction result (manual cleanup needed)
          if [ "${{ needs.create-gpu-droplet.outputs.creation-success }}" = "true" ]; then
            echo "### ‚ö†Ô∏è GPU Cleanup: MANUAL REQUIRED" >> $GITHUB_STEP_SUMMARY
            echo "üîÑ **Automatic GPU cleanup is currently disabled.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Manual GPU cleanup required:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "doctl compute droplet delete ${{ needs.create-gpu-droplet.outputs.droplet-id }} --force" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**GPU Droplet Details:**" >> $GITHUB_STEP_SUMMARY
            echo "- **ID:** \`${{ needs.create-gpu-droplet.outputs.droplet-id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Name:** \`${{ needs.create-gpu-droplet.outputs.droplet-name }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ÑπÔ∏è GPU Cleanup: SKIPPED" >> $GITHUB_STEP_SUMMARY
            echo "No GPU droplet was created, so no cleanup needed." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*This test creates a GPU droplet to verify capacity and functionality. GPU droplet requires manual cleanup.*" >> $GITHUB_STEP_SUMMARY